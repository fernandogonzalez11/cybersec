#!/usr/bin/env python3
# crack_lcg.py
# Usage: edit values[] below and optional CIPHERTEXT_HEX, run `python3 crack_lcg.py`

#from Crypto.Cipher import AES
#from Crypto.Util.Padding import unpad

# --------------------------
# Paste the observed 64-bit outputs here (as Python ints)
values = [14841917648858837769, 9575471537143015742, 15844238770919434615, 5212260032608174747, 9233247444323572291, 10459091850700078324, 6348171461039085016, 11275083358377081726, 15851907641654315174, 5642462723638664555, 12166934227670445515, 16652002833255337213, 1100331227495018541, 17310052757528676070, 10647848709476991180, 7381860977210638817, 14749898712454789023, 9867793747622460486, 1616048454543341186, 8104578690941366513, 4083347094007115737, 11760837183986471162, 16862797396993697119, 1174637638031988756, 1804745826465075031, 16276632568687926630, 5043494920323747028, 11409272895120917919, 16265611200345769799, 14970614558261079002, 2250516726687967919, 1197248850350389243, 14603131310865530726, 16548361948476584779, 13353652992939482174, 13336486704510937571, 10441893770111811970, 4107764688249514273, 11772797255441774916, 12518165417933617541, 7010550077174075010, 14001355721098446832, 437777177382829002, 1722164767628433760, 6559647342847449596, 7938756427230732045, 13281366260429048930, 13092183655381323106, 11806529132310996843, 13947964017447178113, 4621312151518731422, 12501874612357040563, 10826458102042992364, 2159902472703790642, 13882393964322032422, 6529148921315953891, 10134887505878190392, 10419951393751420634, 10135848342454860542, 14313363158598253532, 8934368669847669830, 5124101360181491049, 14913219354552074425, 10908282099950928722, 4253964689299281724, 7407726974875151040, 14219905121435863470, 4181337490774743589, 4184184504223738823, 16936150976212002434, 14433936574129760038, 15520881989251542597, 11194070033146759221, 18174433602168311426, 13020442067015339358, 4382990166888652495, 10254297534043164279, 3817100944212579597, 5331877218604250458, 7185825545642354761, 338711531771068892, 10250264203376128253, 7359215208260510617, 14277514750873457414, 3460304295915392143, 3818816217224032441, 4483483566282319717, 2866544513807354462, 12135646457812113066, 8778669990047144231, 12989768322575258896, 8988116933722638298, 15692389573895602242, 4456647617936315332, 6039845569195475247, 14311304340715617600, 17295981409675358596, 11427453308135142971, 9052862849088317754, 6137397312278782739, 9544766266324391091, 16447228426027058890, 13803636818363488657, 16670480602864962535, 3351397243085772246, 5665702184993835815, 16424003006508152011, 13976194469704404585, 401185194999070420, 5699512823604259627, 17357160984615588720, 3670786096561696620, 4323747368693388297, 10876978042181159325, 7883125366518538304, 2344284687610109741, 12391759147373797536, 12590053927293200960, 8879156692797105548, 8461065756503570819, 17573320578141302871, 15642604376730203427, 12749133263385207476, 4133105186664632492, 18028280465459656846, 3067339009189147778, 15204862189705497345, 18132974384436241649, 8091492506662448517, 18147014166549437993, 5201643316892664569, 3104017212583314140, 3368545846626480386, 14752755621090773653, 9816609813405607817, 10989512726787524104, 17941375633925480992, 5969536734982737360, 3324460409144811670, 14364167734200742327, 10841885411537515505, 12033027733536926218, 13019115357341976440, 13723571084095846113, 14963449044276506843, 9241404467774916626, 1173475476199930336, 10007814422905689012, 880823326108631285, 2864914879726840475, 12348071585001057949, 6441302746542868688, 4806991077471213319, 8933141648678945175, 11649694907667295433, 8708277013041751508, 11719418456350910218, 16635157254108725579, 2134377351096125475, 10289961173017455600, 7055962786096505116, 21728601024181168, 16456998880597164728, 17216116874066795215, 3380132322173996284, 13114502767808007100, 4207348709474901930, 12916699834279235125, 15877440687400786825, 4585779573201771030, 3370966433634988692, 6413163656213101252, 8735986678159831147, 14813660282203931848, 4336269858741206951, 7680697319476289935, 3057350045239125021, 437484923622226917, 12182392489340614340, 7344380605957273905, 1047582581395548343, 9669150555048976950, 3445073427932842783, 5988003049280873305, 9984210927208328016, 8558400548885959238, 14932071850589169092, 10998241484982990572, 4061032217328993314, 16299495071317926943, 14159713152585339233, 7943955737745599039, 2708719529779063308, 5915795415723872866, 15610632814203455383, 9659638034966636775, 10804220067446596648, 3339259544022408735, 16353934319513835005, 7564345426168321381]
# Optional: ciphertext printed by challenge (as hex)
CIPHERTEXT_HEX = None
# --------------------------

# Berlekampâ€“Massey over GF(2)
def berlekamp_massey(s):
    n = len(s)
    C = [1] + [0] * n
    B = [1] + [0] * n
    L = 0
    m = 1
    for N in range(n):
        # discrepancy d = s[N] + sum_{i=1..L} C[i]*s[N-i]
        d = s[N]
        for i in range(1, L+1):
            d ^= (C[i] & s[N-i])
        if d == 1:
            T = C[:]  # copy
            # C = C + x^m * B  (over GF(2), addition = xor)
            for i in range(0, n - N + m):
                if (m + i) < len(C) and i < len(B):
                    C[m + i] ^= B[i]
            if 2 * L <= N:
                L_new = N + 1 - L
                B = T
                L = L_new
                m = 1
            else:
                m += 1
        else:
            m += 1
    return C[:L+1], L

# predict `count` future bits given last L bits and connection poly C (C[0]=1)
def predict_bits(initial_bits, C, L, count):
    state = initial_bits[:]  # list of bits, oldest..newest
    out = []
    for _ in range(count):
        # next = sum_{i=1..L} C[i] * state[-i]
        nxt = 0
        for i in range(1, L+1):
            if C[i]:
                nxt ^= state[-i]
        out.append(nxt)
        state.append(nxt)
        state.pop(0)
    return out

# extract single-bit stream from the 64-bit word sequence
def bit_stream(values, bitpos, lsb_first=True):
    if lsb_first:
        return [ (v >> bitpos) & 1 for v in values ]
    else:
        # treat bitpos=0 as MSB of 64-bit word (rare), so map accordingly
        return [ (v >> (63 - bitpos)) & 1 for v in values ]

# TRY: per-bit BM, reconstruct v1 and v2
def recover_v1_v2(values, expected_max_degree=192):
    nvals = len(values)
    v1 = 0
    v2 = 0
    for pos in range(64):
        bits = bit_stream(values, pos, lsb_first=True)
        C, L = berlekamp_massey(bits)
        if L > expected_max_degree:
            bits = bit_stream(values, pos, lsb_first=False)
            C, L = berlekamp_massey(bits)
            if L > expected_max_degree:
                raise RuntimeError(f"bit pos {pos}: unexpected degree {L} (> {expected_max_degree}) -- check values/endian")

        if L == 0:
            next_bits = [0] * 128
        else:
            initial = bits[-L:]     # oldest..newest
            next_bits = predict_bits(initial, C, L, 128)

        # CORRECT ASSEMBLY: use only the next bit for v1 and the 65th for v2
        if next_bits[0]:
            v1 |= (1 << pos)
        if next_bits[64]:
            v2 |= (1 << pos)

    return v1, v2


def build_key_bytes(v1, v2):
    key_int = v1 + (v2 << 64)
    return key_int.to_bytes(16, 'big')

if __name__ == "__main__":
    print(f"observed {len(values)} outputs")
    v1, v2 = recover_v1_v2(values)
    print("v1 = 0x{:016x}".format(v1))
    print("v2 = 0x{:016x}".format(v2))
    key = build_key_bytes(v1, v2)
    print("key =", key.hex())
    if CIPHERTEXT_HEX:
        ct = bytes.fromhex(CIPHERTEXT_HEX)
        cipher = AES.new(key, AES.MODE_ECB)
        try:
            pt = unpad(cipher.decrypt(ct), 16)
            print("plaintext:", pt.decode(errors='replace'))
        except Exception as e:
            print("decryption failed:", e)


"""
$ python3 crack.py 
observed 200 outputs
v1 = 0xdd3107b18697858d
v2 = 0xf2021989125fe9f5
key = f2021989125fe9f5dd3107b18697858d

f2021989125fe9f5dd3107b18697858d
"""
